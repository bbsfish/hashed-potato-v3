let XMLValidator; (() => {
  const e = { 839: (e, t) => { const r = '[:A-Za-z_\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][:A-Za-z_\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.\\d\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*'; const n = new RegExp(`^${r}$`); t.isExist = function (e) { return void 0 !== e; }, t.isEmptyObject = function (e) { return Object.keys(e).length === 0; }, t.merge = function (e, t, r) { if (t) for (let n = Object.keys(t), i = n.length, a = 0; a < i; a++)e[n[a]] = r === 'strict' ? [t[n[a]]] : t[n[a]]; }, t.getValue = function (e) { return t.isExist(e) ? e : ''; }, t.isName = function (e) { return !(n.exec(e) == null); }, t.getAllMatches = function (e, t) { for (var r = [], n = t.exec(e); n;) { const i = []; i.startIndex = t.lastIndex - n[0].length; for (let a = n.length, u = 0; u < a; u++)i.push(n[u]); r.push(i), n = t.exec(e); } return r; }, t.nameRegexp = r; } }; const t = {}; function r(n) { const i = t[n]; if (void 0 !== i) return i.exports; const a = t[n] = { exports: {} }; return e[n](a, a.exports, r), a.exports; } const n = {}; (() => {
    const e = n; const t = r(839); const i = { allowBooleanAttributes: !1, unpairedTags: [] }; function a(e) { return e === ' ' || e === '\t' || e === '\n' || e === '\r'; } function u(e, t) { for (let r = t; t < e.length; t++) if (e[t] != '?' && e[t] != ' ');else { const n = e.substr(r, t - r); if (t > 5 && n === 'xml') return v('InvalidXml', 'XML declaration allowed only at the start of the document.', c(e, t)); if (e[t] == '?' && e[t + 1] == '>') { t++; break; } } return t; } function l(e, t) { if (e.length > t + 5 && e[t + 1] === '-' && e[t + 2] === '-') { for (t += 3; t < e.length; t++) if (e[t] === '-' && e[t + 1] === '-' && e[t + 2] === '>') { t += 2; break; } } else if (e.length > t + 8 && e[t + 1] === 'D' && e[t + 2] === 'O' && e[t + 3] === 'C' && e[t + 4] === 'T' && e[t + 5] === 'Y' && e[t + 6] === 'P' && e[t + 7] === 'E') { let r = 1; for (t += 8; t < e.length; t++) if (e[t] === '<')r++; else if (e[t] === '>' && --r == 0) break; } else if (e.length > t + 9 && e[t + 1] === '[' && e[t + 2] === 'C' && e[t + 3] === 'D' && e[t + 4] === 'A' && e[t + 5] === 'T' && e[t + 6] === 'A' && e[t + 7] === '[') for (t += 8; t < e.length; t++) if (e[t] === ']' && e[t + 1] === ']' && e[t + 2] === '>') { t += 2; break; } return t; } function o(e, t) { for (var r = '', n = '', i = !1; t < e.length; t++) { if (e[t] === '"' || e[t] === "'")n === '' ? n = e[t] : n !== e[t] || (n = ''); else if (e[t] === '>' && n === '') { i = !0; break; }r += e[t]; } return n === '' && { value: r, index: t, tagClosed: i }; }e.validate = function (e, r) { r = { ...i, ...r }; let n; const f = []; let d = !1; let h = !1; e[0] === '\ufeff' && (e = e.substr(1)); for (let F = 0; F < e.length; F++) if (e[F] === '<' && e[F + 1] === '?') { if ((F = u(e, F += 2)).err) return F; } else { if (e[F] !== '<') { if (a(e[F])) continue; return v('InvalidChar', `char '${e[F]}' is not expected.`, c(e, F)); } const p = F; if (e[++F] === '!') { F = l(e, F); continue; } let m = !1; e[F] === '/' && (m = !0, F++); for (var b = ''; F < e.length && e[F] !== '>' && e[F] !== ' ' && e[F] !== '\t' && e[F] !== '\n' && e[F] !== '\r'; F++)b += e[F]; if ((b = b.trim())[b.length - 1] === '/' && (b = b.substring(0, b.length - 1), F--), n = b, !t.isName(n)) return v('InvalidTag', b.trim().length === 0 ? "Invalid space after '<'." : `Tag '${b}' is an invalid name.`, c(e, F)); const x = o(e, F); if (!1 === x) return v('InvalidAttr', `Attributes for '${b}' have open quote.`, c(e, F)); let I = x.value; if (F = x.index, I[I.length - 1] === '/') { const A = F - I.length; const D = s(I = I.substring(0, I.length - 1), r); if (!0 !== D) return v(D.err.code, D.err.msg, c(e, A + D.err.line)); d = !0; } else if (m) { if (!x.tagClosed) return v('InvalidTag', `Closing tag '${b}' doesn't have proper closing.`, c(e, F)); if (I.trim().length > 0) return v('InvalidTag', `Closing tag '${b}' can't have attributes or invalid starting.`, c(e, p)); const C = f.pop(); if (b !== C.tagName) { const k = c(e, C.tagStartPos); return v('InvalidTag', `Expected closing tag '${C.tagName}' (opened in line ${k.line}, col ${k.col}) instead of closing tag '${b}'.`, c(e, p)); }f.length == 0 && (h = !0); } else { const E = s(I, r); if (!0 !== E) return v(E.err.code, E.err.msg, c(e, F - I.length + E.err.line)); if (!0 === h) return v('InvalidXml', 'Multiple possible root nodes found.', c(e, F)); r.unpairedTags.indexOf(b) !== -1 || f.push({ tagName: b, tagStartPos: p }), d = !0; } for (F++; F < e.length; F++) if (e[F] === '<') { if (e[F + 1] === '!') { F = l(e, ++F); continue; } if (e[F + 1] !== '?') break; if ((F = u(e, ++F)).err) return F; } else if (e[F] === '&') { const T = g(e, F); if (T == -1) return v('InvalidChar', "char '&' is not expected.", c(e, F)); F = T; } else if (!0 === h && !a(e[F])) return v('InvalidXml', 'Extra text at the end', c(e, F)); e[F] === '<' && F--; } return d ? f.length == 1 ? v('InvalidTag', `Unclosed tag '${f[0].tagName}'.`, c(e, f[0].tagStartPos)) : !(f.length > 0) || v('InvalidXml', `Invalid '${JSON.stringify(f.map(((e) => e.tagName)), null, 4).replace(/\r?\n/g, '')}' found.`, { line: 1, col: 1 }) : v('InvalidXml', 'Start tag expected.', 1); }; const f = new RegExp("(\\s*)([^\\s=]+)(\\s*=)?(\\s*(['\"])(([\\s\\S])*?)\\5)?", 'g'); function s(e, r) { for (let n = t.getAllMatches(e, f), i = {}, a = 0; a < n.length; a++) { if (n[a][1].length === 0) return v('InvalidAttr', `Attribute '${n[a][2]}' has no space in starting.`, h(n[a])); if (void 0 !== n[a][3] && void 0 === n[a][4]) return v('InvalidAttr', `Attribute '${n[a][2]}' is without value.`, h(n[a])); if (void 0 === n[a][3] && !r.allowBooleanAttributes) return v('InvalidAttr', `boolean attribute '${n[a][2]}' is not allowed.`, h(n[a])); const u = n[a][2]; if (!d(u)) return v('InvalidAttr', `Attribute '${u}' is an invalid name.`, h(n[a])); if (i.hasOwnProperty(u)) return v('InvalidAttr', `Attribute '${u}' is repeated.`, h(n[a])); i[u] = 1; } return !0; } function g(e, t) { if (e[++t] === ';') return -1; if (e[t] === '#') return (function (e, t) { let r = /\d/; for (e[t] === 'x' && (t++, r = /[\da-fA-F]/); t < e.length; t++) { if (e[t] === ';') return t; if (!e[t].match(r)) break; } return -1; }(e, ++t)); for (let r = 0; t < e.length; t++, r++) if (!(e[t].match(/\w/) && r < 20)) { if (e[t] === ';') break; return -1; } return t; } function v(e, t, r) {
      return {
        err: {
          code: e, msg: t, line: r.line || r, col: r.col,
        },
      };
    } function d(e) { return t.isName(e); } function c(e, t) { const r = e.substring(0, t).split(/\r?\n/); return { line: r.length, col: r[r.length - 1].length + 1 }; } function h(e) { return e.startIndex + e[1].length; }
  })(), XMLValidator = n;
})();
// # sourceMappingURL=fxvalidator.min.js.map
