let fxp; (() => {
  const t = {
    807: (t) => {
      const e = /^[-+]?0x[a-fA-F0-9]+$/; const r = /^([\-\+])?(0*)(\.[0-9]+([eE]\-?[0-9]+)?|[0-9]+(\.[0-9]+([eE]\-?[0-9]+)?)?)$/; !Number.parseInt && window.parseInt && (Number.parseInt = window.parseInt), !Number.parseFloat && window.parseFloat && (Number.parseFloat = window.parseFloat); const i = {
        hex: !0, leadingZeros: !0, decimalPoint: '.', eNotation: !0,
      }; t.exports = function (t, n = {}) { if (n = { ...i, ...n }, !t || typeof t !== 'string') return t; const s = t.trim(); if (void 0 !== n.skipLike && n.skipLike.test(s)) return t; if (n.hex && e.test(s)) return Number.parseInt(s, 16); { const e = r.exec(s); if (e) { const r = e[1]; const i = e[2]; const o = (a = e[3]) && a.indexOf('.') !== -1 ? ((a = a.replace(/0+$/, '')) === '.' ? a = '0' : a[0] === '.' ? a = `0${a}` : a[a.length - 1] === '.' && (a = a.substr(0, a.length - 1)), a) : a; const u = e[4] || e[6]; if (!n.leadingZeros && i.length > 0 && r && s[2] !== '.') return t; if (!n.leadingZeros && i.length > 0 && !r && s[1] !== '.') return t; { const e = Number(s); const a = `${e}`; return a.search(/[eE]/) !== -1 || u ? n.eNotation ? e : t : s.indexOf('.') !== -1 ? a === '0' && o === '' || a === o || r && a === `-${o}` ? e : t : i ? o === a || r + o === a ? e : t : s === a || s === r + a ? e : t; } } return t; } let a; };
    },
    316: (t, e, r) => {
      const i = r(239); const n = r(870); const s = r(784); t.exports = { XMLParser: n, XMLValidator: i, XMLBuilder: s };
    },
    839: (t, e) => {
      const r = '[:A-Za-z_\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][:A-Za-z_\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.\\d\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*'; const i = new RegExp(`^${r}$`); e.isExist = function (t) { return void 0 !== t; }, e.isEmptyObject = function (t) { return Object.keys(t).length === 0; }, e.merge = function (t, e, r) { if (e) for (let i = Object.keys(e), n = i.length, s = 0; s < n; s++)t[i[s]] = r === 'strict' ? [e[i[s]]] : e[i[s]]; }, e.getValue = function (t) { return e.isExist(t) ? t : ''; }, e.isName = function (t) { return !(i.exec(t) == null); }, e.getAllMatches = function (t, e) { for (var r = [], i = e.exec(t); i;) { const n = []; n.startIndex = e.lastIndex - i[0].length; for (let s = i.length, a = 0; a < s; a++)n.push(i[a]); r.push(n), i = e.exec(t); } return r; }, e.nameRegexp = r;
    },
    239: (t, e, r) => {
      const i = r(839); const n = { allowBooleanAttributes: !1, unpairedTags: [] }; function s(t) { return t === ' ' || t === '\t' || t === '\n' || t === '\r'; } function a(t, e) { for (let r = e; e < t.length; e++) if (t[e] != '?' && t[e] != ' ');else { const i = t.substr(r, e - r); if (e > 5 && i === 'xml') return d('InvalidXml', 'XML declaration allowed only at the start of the document.', g(t, e)); if (t[e] == '?' && t[e + 1] == '>') { e++; break; } } return e; } function o(t, e) { if (t.length > e + 5 && t[e + 1] === '-' && t[e + 2] === '-') { for (e += 3; e < t.length; e++) if (t[e] === '-' && t[e + 1] === '-' && t[e + 2] === '>') { e += 2; break; } } else if (t.length > e + 8 && t[e + 1] === 'D' && t[e + 2] === 'O' && t[e + 3] === 'C' && t[e + 4] === 'T' && t[e + 5] === 'Y' && t[e + 6] === 'P' && t[e + 7] === 'E') { let r = 1; for (e += 8; e < t.length; e++) if (t[e] === '<')r++; else if (t[e] === '>' && --r == 0) break; } else if (t.length > e + 9 && t[e + 1] === '[' && t[e + 2] === 'C' && t[e + 3] === 'D' && t[e + 4] === 'A' && t[e + 5] === 'T' && t[e + 6] === 'A' && t[e + 7] === '[') for (e += 8; e < t.length; e++) if (t[e] === ']' && t[e + 1] === ']' && t[e + 2] === '>') { e += 2; break; } return e; } function u(t, e) { for (var r = '', i = '', n = !1; e < t.length; e++) { if (t[e] === '"' || t[e] === "'")i === '' ? i = t[e] : i !== t[e] || (i = ''); else if (t[e] === '>' && i === '') { n = !0; break; }r += t[e]; } return i === '' && { value: r, index: e, tagClosed: n }; }e.validate = function (t, e) { e = { ...n, ...e }; let r; const l = []; let f = !1; let c = !1; t[0] === '\ufeff' && (t = t.substr(1)); for (let v = 0; v < t.length; v++) if (t[v] === '<' && t[v + 1] === '?') { if ((v = a(t, v += 2)).err) return v; } else { if (t[v] !== '<') { if (s(t[v])) continue; return d('InvalidChar', `char '${t[v]}' is not expected.`, g(t, v)); } const x = v; if (t[++v] === '!') { v = o(t, v); continue; } let m = !1; t[v] === '/' && (m = !0, v++); for (var N = ''; v < t.length && t[v] !== '>' && t[v] !== ' ' && t[v] !== '\t' && t[v] !== '\n' && t[v] !== '\r'; v++)N += t[v]; if ((N = N.trim())[N.length - 1] === '/' && (N = N.substring(0, N.length - 1), v--), r = N, !i.isName(r)) return d('InvalidTag', N.trim().length === 0 ? "Invalid space after '<'." : `Tag '${N}' is an invalid name.`, g(t, v)); const b = u(t, v); if (!1 === b) return d('InvalidAttr', `Attributes for '${N}' have open quote.`, g(t, v)); let E = b.value; if (v = b.index, E[E.length - 1] === '/') { const T = v - E.length; const y = h(E = E.substring(0, E.length - 1), e); if (!0 !== y) return d(y.err.code, y.err.msg, g(t, T + y.err.line)); f = !0; } else if (m) { if (!b.tagClosed) return d('InvalidTag', `Closing tag '${N}' doesn't have proper closing.`, g(t, v)); if (E.trim().length > 0) return d('InvalidTag', `Closing tag '${N}' can't have attributes or invalid starting.`, g(t, x)); const O = l.pop(); if (N !== O.tagName) { const A = g(t, O.tagStartPos); return d('InvalidTag', `Expected closing tag '${O.tagName}' (opened in line ${A.line}, col ${A.col}) instead of closing tag '${N}'.`, g(t, x)); }l.length == 0 && (c = !0); } else { const w = h(E, e); if (!0 !== w) return d(w.err.code, w.err.msg, g(t, v - E.length + w.err.line)); if (!0 === c) return d('InvalidXml', 'Multiple possible root nodes found.', g(t, v)); e.unpairedTags.indexOf(N) !== -1 || l.push({ tagName: N, tagStartPos: x }), f = !0; } for (v++; v < t.length; v++) if (t[v] === '<') { if (t[v + 1] === '!') { v = o(t, ++v); continue; } if (t[v + 1] !== '?') break; if ((v = a(t, ++v)).err) return v; } else if (t[v] === '&') { const P = p(t, v); if (P == -1) return d('InvalidChar', "char '&' is not expected.", g(t, v)); v = P; } else if (!0 === c && !s(t[v])) return d('InvalidXml', 'Extra text at the end', g(t, v)); t[v] === '<' && v--; } return f ? l.length == 1 ? d('InvalidTag', `Unclosed tag '${l[0].tagName}'.`, g(t, l[0].tagStartPos)) : !(l.length > 0) || d('InvalidXml', `Invalid '${JSON.stringify(l.map(((t) => t.tagName)), null, 4).replace(/\r?\n/g, '')}' found.`, { line: 1, col: 1 }) : d('InvalidXml', 'Start tag expected.', 1); }; const l = new RegExp("(\\s*)([^\\s=]+)(\\s*=)?(\\s*(['\"])(([\\s\\S])*?)\\5)?", 'g'); function h(t, e) { for (let r = i.getAllMatches(t, l), n = {}, s = 0; s < r.length; s++) { if (r[s][1].length === 0) return d('InvalidAttr', `Attribute '${r[s][2]}' has no space in starting.`, c(r[s])); if (void 0 !== r[s][3] && void 0 === r[s][4]) return d('InvalidAttr', `Attribute '${r[s][2]}' is without value.`, c(r[s])); if (void 0 === r[s][3] && !e.allowBooleanAttributes) return d('InvalidAttr', `boolean attribute '${r[s][2]}' is not allowed.`, c(r[s])); const a = r[s][2]; if (!f(a)) return d('InvalidAttr', `Attribute '${a}' is an invalid name.`, c(r[s])); if (n.hasOwnProperty(a)) return d('InvalidAttr', `Attribute '${a}' is repeated.`, c(r[s])); n[a] = 1; } return !0; } function p(t, e) { if (t[++e] === ';') return -1; if (t[e] === '#') return (function (t, e) { let r = /\d/; for (t[e] === 'x' && (e++, r = /[\da-fA-F]/); e < t.length; e++) { if (t[e] === ';') return e; if (!t[e].match(r)) break; } return -1; }(t, ++e)); for (let r = 0; e < t.length; e++, r++) if (!(t[e].match(/\w/) && r < 20)) { if (t[e] === ';') break; return -1; } return e; } function d(t, e, r) {
        return {
          err: {
            code: t, msg: e, line: r.line || r, col: r.col,
          },
        };
      } function f(t) { return i.isName(t); } function g(t, e) { const r = t.substring(0, e).split(/\r?\n/); return { line: r.length, col: r[r.length - 1].length + 1 }; } function c(t) { return t.startIndex + t[1].length; }
    },
    784: (t, e, r) => {
      const i = r(687); const n = {
        attributeNamePrefix: '@_', attributesGroupName: !1, textNodeName: '#text', ignoreAttributes: !0, cdataPropName: !1, format: !1, indentBy: '  ', suppressEmptyNode: !1, suppressUnpairedNode: !0, suppressBooleanAttributes: !0, tagValueProcessor(t, e) { return e; }, attributeValueProcessor(t, e) { return e; }, preserveOrder: !1, commentPropName: !1, unpairedTags: [], entities: [{ regex: new RegExp('&', 'g'), val: '&amp;' }, { regex: new RegExp('>', 'g'), val: '&gt;' }, { regex: new RegExp('<', 'g'), val: '&lt;' }, { regex: new RegExp("'", 'g'), val: '&apos;' }, { regex: new RegExp('"', 'g'), val: '&quot;' }], processEntities: !0, stopNodes: [], oneListGroup: !1,
      }; function s(t) { this.options = { ...n, ...t }, this.options.ignoreAttributes || this.options.attributesGroupName ? this.isAttribute = function () { return !1; } : (this.attrPrefixLen = this.options.attributeNamePrefix.length, this.isAttribute = u), this.processTextOrObjNode = a, this.options.format ? (this.indentate = o, this.tagEndChar = '>\n', this.newLine = '\n') : (this.indentate = function () { return ''; }, this.tagEndChar = '>', this.newLine = ''); } function a(t, e, r) { const i = this.j2x(t, r + 1); return void 0 !== t[this.options.textNodeName] && Object.keys(t).length === 1 ? this.buildTextValNode(t[this.options.textNodeName], e, i.attrStr, r) : this.buildObjectNode(i.val, e, i.attrStr, r); } function o(t) { return this.options.indentBy.repeat(t); } function u(t) { return !(!t.startsWith(this.options.attributeNamePrefix) || t === this.options.textNodeName) && t.substr(this.attrPrefixLen); }s.prototype.build = function (t) { return this.options.preserveOrder ? i(t, this.options) : (Array.isArray(t) && this.options.arrayNodeName && this.options.arrayNodeName.length > 1 && ((e = {})[this.options.arrayNodeName] = t, t = e), this.j2x(t, 0).val); let e; }, s.prototype.j2x = function (t, e) { let r = ''; let i = ''; for (const n in t) if (Object.prototype.hasOwnProperty.call(t, n)) if (void 0 === t[n]) this.isAttribute(n) && (i += ''); else if (t[n] === null) this.isAttribute(n) ? i += '' : n[0] === '?' ? i += `${this.indentate(e)}<${n}?${this.tagEndChar}` : i += `${this.indentate(e)}<${n}/${this.tagEndChar}`; else if (t[n] instanceof Date)i += this.buildTextValNode(t[n], n, '', e); else if (typeof t[n] !== 'object') { const s = this.isAttribute(n); if (s)r += this.buildAttrPairStr(s, `${t[n]}`); else if (n === this.options.textNodeName) { const a = this.options.tagValueProcessor(n, `${t[n]}`); i += this.replaceEntitiesValue(a); } else i += this.buildTextValNode(t[n], n, '', e); } else if (Array.isArray(t[n])) { for (var o = t[n].length, u = '', l = 0; l < o; l++) { const h = t[n][l]; void 0 === h || (h === null ? n[0] === '?' ? i += `${this.indentate(e)}<${n}?${this.tagEndChar}` : i += `${this.indentate(e)}<${n}/${this.tagEndChar}` : typeof h === 'object' ? this.options.oneListGroup ? u += this.j2x(h, e + 1).val : u += this.processTextOrObjNode(h, n, e) : u += this.buildTextValNode(h, n, '', e)); } this.options.oneListGroup && (u = this.buildObjectNode(u, n, '', e)), i += u; } else if (this.options.attributesGroupName && n === this.options.attributesGroupName) for (let p = Object.keys(t[n]), d = p.length, f = 0; f < d; f++)r += this.buildAttrPairStr(p[f], `${t[n][p[f]]}`); else i += this.processTextOrObjNode(t[n], n, e); return { attrStr: r, val: i }; }, s.prototype.buildAttrPairStr = function (t, e) { return e = this.options.attributeValueProcessor(t, `${e}`), e = this.replaceEntitiesValue(e), this.options.suppressBooleanAttributes && e === 'true' ? ` ${t}` : ` ${t}="${e}"`; }, s.prototype.buildObjectNode = function (t, e, r, i) { if (t === '') return e[0] === '?' ? `${this.indentate(i)}<${e}${r}?${this.tagEndChar}` : `${this.indentate(i)}<${e}${r}${this.closeTag(e)}${this.tagEndChar}`; let n = `</${e}${this.tagEndChar}`; let s = ''; return e[0] === '?' && (s = '?', n = ''), !r && r !== '' || t.indexOf('<') !== -1 ? !1 !== this.options.commentPropName && e === this.options.commentPropName && s.length === 0 ? `${this.indentate(i)}\x3c!--${t}--\x3e${this.newLine}` : `${this.indentate(i)}<${e}${r}${s}${this.tagEndChar}${t}${this.indentate(i)}${n}` : `${this.indentate(i)}<${e}${r}${s}>${t}${n}`; }, s.prototype.closeTag = function (t) { let e = ''; return this.options.unpairedTags.indexOf(t) !== -1 ? this.options.suppressUnpairedNode || (e = '/') : e = this.options.suppressEmptyNode ? '/' : `></${t}`, e; }, s.prototype.buildTextValNode = function (t, e, r, i) { if (!1 !== this.options.cdataPropName && e === this.options.cdataPropName) return `${this.indentate(i)}<![CDATA[${t}]]>${this.newLine}`; if (!1 !== this.options.commentPropName && e === this.options.commentPropName) return `${this.indentate(i)}\x3c!--${t}--\x3e${this.newLine}`; if (e[0] === '?') return `${this.indentate(i)}<${e}${r}?${this.tagEndChar}`; let n = this.options.tagValueProcessor(e, t); return (n = this.replaceEntitiesValue(n)) === '' ? `${this.indentate(i)}<${e}${r}${this.closeTag(e)}${this.tagEndChar}` : `${this.indentate(i)}<${e}${r}>${n}</${e}${this.tagEndChar}`; }, s.prototype.replaceEntitiesValue = function (t) { if (t && t.length > 0 && this.options.processEntities) for (let e = 0; e < this.options.entities.length; e++) { const r = this.options.entities[e]; t = t.replace(r.regex, r.val); } return t; }, t.exports = s;
    },
    687: (t) => { function e(t, a, o, u) { for (var l = '', h = !1, p = 0; p < t.length; p++) { const d = t[p]; const f = r(d); if (void 0 !== f) { var g; if (g = o.length === 0 ? f : `${o}.${f}`, f !== a.textNodeName) if (f !== a.cdataPropName) if (f !== a.commentPropName) if (f[0] !== '?') { let c = u; c !== '' && (c += a.indentBy); const v = `${u}<${f}${i(d[':@'], a)}`; const x = e(d[f], a, g, c); a.unpairedTags.indexOf(f) !== -1 ? a.suppressUnpairedNode ? l += `${v}>` : l += `${v}/>` : x && x.length !== 0 || !a.suppressEmptyNode ? x && x.endsWith('>') ? l += `${v}>${x}${u}</${f}>` : (l += `${v}>`, x && u !== '' && (x.includes('/>') || x.includes('</')) ? l += u + a.indentBy + x + u : l += x, l += `</${f}>`) : l += `${v}/>`, h = !0; } else { const m = i(d[':@'], a); const N = f === '?xml' ? '' : u; let b = d[f][0][a.textNodeName]; l += `${N}<${f}${b = b.length !== 0 ? ` ${b}` : ''}${m}?>`, h = !0; } else l += `${u}\x3c!--${d[f][0][a.textNodeName]}--\x3e`, h = !0; else h && (l += u), l += `<![CDATA[${d[f][0][a.textNodeName]}]]>`, h = !1; else { let E = d[f]; n(g, a) || (E = s(E = a.tagValueProcessor(f, E), a)), h && (l += u), l += E, h = !1; } } } return l; } function r(t) { for (let e = Object.keys(t), r = 0; r < e.length; r++) { const i = e[r]; if (t.hasOwnProperty(i) && i !== ':@') return i; } } function i(t, e) { let r = ''; if (t && !e.ignoreAttributes) for (const i in t) if (t.hasOwnProperty(i)) { let n = e.attributeValueProcessor(i, t[i]); !0 === (n = s(n, e)) && e.suppressBooleanAttributes ? r += ` ${i.substr(e.attributeNamePrefix.length)}` : r += ` ${i.substr(e.attributeNamePrefix.length)}="${n}"`; } return r; } function n(t, e) { const r = (t = t.substr(0, t.length - e.textNodeName.length - 1)).substr(t.lastIndexOf('.') + 1); for (const i in e.stopNodes) if (e.stopNodes[i] === t || e.stopNodes[i] === `*.${r}`) return !0; return !1; } function s(t, e) { if (t && t.length > 0 && e.processEntities) for (let r = 0; r < e.entities.length; r++) { const i = e.entities[r]; t = t.replace(i.regex, i.val); } return t; }t.exports = function (t, r) { let i = ''; return r.format && r.indentBy.length > 0 && (i = '\n'), e(t, r, '', i); }; },
    106: (t, e, r) => { const i = r(839); function n(t, e) { for (var r = ''; e < t.length && t[e] !== "'" && t[e] !== '"'; e++)r += t[e]; if ((r = r.trim()).indexOf(' ') !== -1) throw new Error('External entites are not supported'); for (var i = t[e++], n = ''; e < t.length && t[e] !== i; e++)n += t[e]; return [r, n, e]; } function s(t, e) { return t[e + 1] === '!' && t[e + 2] === '-' && t[e + 3] === '-'; } function a(t, e) { return t[e + 1] === '!' && t[e + 2] === 'E' && t[e + 3] === 'N' && t[e + 4] === 'T' && t[e + 5] === 'I' && t[e + 6] === 'T' && t[e + 7] === 'Y'; } function o(t, e) { return t[e + 1] === '!' && t[e + 2] === 'E' && t[e + 3] === 'L' && t[e + 4] === 'E' && t[e + 5] === 'M' && t[e + 6] === 'E' && t[e + 7] === 'N' && t[e + 8] === 'T'; } function u(t, e) { return t[e + 1] === '!' && t[e + 2] === 'A' && t[e + 3] === 'T' && t[e + 4] === 'T' && t[e + 5] === 'L' && t[e + 6] === 'I' && t[e + 7] === 'S' && t[e + 8] === 'T'; } function l(t, e) { return t[e + 1] === '!' && t[e + 2] === 'N' && t[e + 3] === 'O' && t[e + 4] === 'T' && t[e + 5] === 'A' && t[e + 6] === 'T' && t[e + 7] === 'I' && t[e + 8] === 'O' && t[e + 9] === 'N'; } function h(t) { if (i.isName(t)) return t; throw new Error(`Invalid entity name ${t}`); }t.exports = function (t, e) { const r = {}; if (t[e + 3] !== 'O' || t[e + 4] !== 'C' || t[e + 5] !== 'T' || t[e + 6] !== 'Y' || t[e + 7] !== 'P' || t[e + 8] !== 'E') throw new Error('Invalid Tag instead of DOCTYPE'); e += 9; for (var i = 1, p = !1, d = !1; e < t.length; e++) if (t[e] !== '<' || d) if (t[e] === '>') { if (d ? t[e - 1] === '-' && t[e - 2] === '-' && (d = !1, i--) : i--, i === 0) break; } else t[e] === '[' ? p = !0 : t[e]; else { if (p && a(t, e)) { const f = n(t, (e += 7) + 1); entityName = f[0], val = f[1], e = f[2], val.indexOf('&') === -1 && (r[h(entityName)] = { regx: RegExp(`&${entityName};`, 'g'), val }); } else if (p && o(t, e))e += 8; else if (p && u(t, e))e += 8; else if (p && l(t, e))e += 9; else { if (!s) throw new Error('Invalid DOCTYPE'); d = !0; }i++; } if (i !== 0) throw new Error('Unclosed DOCTYPE'); return { entities: r, i: e }; }; },
    348: (t, e) => {
      const r = {
        preserveOrder: !1, attributeNamePrefix: '@_', attributesGroupName: !1, textNodeName: '#text', ignoreAttributes: !0, removeNSPrefix: !1, allowBooleanAttributes: !1, parseTagValue: !0, parseAttributeValue: !1, trimValues: !0, cdataPropName: !1, numberParseOptions: { hex: !0, leadingZeros: !0, eNotation: !0 }, tagValueProcessor(t, e) { return e; }, attributeValueProcessor(t, e) { return e; }, stopNodes: [], alwaysCreateTextNode: !1, isArray() { return !1; }, commentPropName: !1, unpairedTags: [], processEntities: !0, htmlEntities: !1, ignoreDeclaration: !1, ignorePiTags: !1, transformTagName: !1, transformAttributeName: !1, updateTag(t, e, r) { return t; },
      }; e.buildOptions = function (t) { return { ...r, ...t }; }, e.defaultOptions = r;
    },
    498: (t, e, r) => {
      const i = r(839); const n = r(876); const s = r(106); const a = r(807); function o(t) { for (let e = Object.keys(t), r = 0; r < e.length; r++) { const i = e[r]; this.lastEntities[i] = { regex: new RegExp(`&${i};`, 'g'), val: t[i] }; } } function u(t, e, r, i, n, s, a) { if (void 0 !== t && (this.options.trimValues && !i && (t = t.trim()), t.length > 0)) { a || (t = this.replaceEntitiesValue(t)); const o = this.options.tagValueProcessor(e, t, r, n, s); return o == null ? t : typeof o !== typeof t || o !== t ? o : this.options.trimValues || t.trim() === t ? b(t, this.options.parseTagValue, this.options.numberParseOptions) : t; } } function l(t) { if (this.options.removeNSPrefix) { const e = t.split(':'); const r = t.charAt(0) === '/' ? '/' : ''; if (e[0] === 'xmlns') return ''; e.length === 2 && (t = r + e[1]); } return t; }'<((!\\[CDATA\\[([\\s\\S]*?)(]]>))|((NAME:)?(NAME))([^>]*)>|((\\/)(NAME)\\s*>))([^<]*)'.replace(/NAME/g, i.nameRegexp); const h = new RegExp("([^\\s=]+)\\s*(=\\s*(['\"])([\\s\\S]*?)\\3)?", 'gm'); function p(t, e, r) { if (!this.options.ignoreAttributes && typeof t === 'string') { for (var n = i.getAllMatches(t, h), s = n.length, a = {}, o = 0; o < s; o++) { const u = this.resolveNameSpace(n[o][1]); let l = n[o][4]; let p = this.options.attributeNamePrefix + u; if (u.length) if (this.options.transformAttributeName && (p = this.options.transformAttributeName(p)), p === '__proto__' && (p = '#__proto__'), void 0 !== l) { this.options.trimValues && (l = l.trim()), l = this.replaceEntitiesValue(l); const d = this.options.attributeValueProcessor(u, l, e); a[p] = d == null ? l : typeof d !== typeof l || d !== l ? d : b(l, this.options.parseAttributeValue, this.options.numberParseOptions); } else this.options.allowBooleanAttributes && (a[p] = !0); } if (!Object.keys(a).length) return; if (this.options.attributesGroupName) { const f = {}; return f[this.options.attributesGroupName] = a, f; } return a; } } const d = function (t) { t = t.replace(/\r\n?/g, '\n'); for (var e = new n('!xml'), r = e, i = '', a = '', o = 0; o < t.length; o++) if (t[o] === '<') if (t[o + 1] === '/') { const u = x(t, '>', o, 'Closing Tag is not closed.'); let l = t.substring(o + 2, u).trim(); if (this.options.removeNSPrefix) { const h = l.indexOf(':'); h !== -1 && (l = l.substr(h + 1)); } this.options.transformTagName && (l = this.options.transformTagName(l)), r && (i = this.saveTextToParentTag(i, r, a)); const p = a.substring(a.lastIndexOf('.') + 1); if (l && this.options.unpairedTags.indexOf(l) !== -1) throw new Error(`Unpaired tag can not be used as closing tag: </${l}>`); let d = 0; p && this.options.unpairedTags.indexOf(p) !== -1 ? (d = a.lastIndexOf('.', a.lastIndexOf('.') - 1), this.tagsNodeStack.pop()) : d = a.lastIndexOf('.'), a = a.substring(0, d), r = this.tagsNodeStack.pop(), i = '', o = u; } else if (t[o + 1] === '?') { const f = m(t, o, !1, '?>'); if (!f) throw new Error('Pi Tag is not closed.'); if (i = this.saveTextToParentTag(i, r, a), this.options.ignoreDeclaration && f.tagName === '?xml' || this.options.ignorePiTags);else { const g = new n(f.tagName); g.add(this.options.textNodeName, ''), f.tagName !== f.tagExp && f.attrExpPresent && (g[':@'] = this.buildAttributesMap(f.tagExp, a, f.tagName)), this.addChild(r, g, a); }o = f.closeIndex + 1; } else if (t.substr(o + 1, 3) === '!--') { const c = x(t, '--\x3e', o + 4, 'Comment is not closed.'); if (this.options.commentPropName) { var v; const N = t.substring(o + 4, c - 2); i = this.saveTextToParentTag(i, r, a), r.add(this.options.commentPropName, [(v = {}, v[this.options.textNodeName] = N, v)]); }o = c; } else if (t.substr(o + 1, 2) === '!D') { const b = s(t, o); this.docTypeEntities = b.entities, o = b.i; } else if (t.substr(o + 1, 2) === '![') { const E = x(t, ']]>', o, 'CDATA is not closed.') - 2; const T = t.substring(o + 9, E); if (i = this.saveTextToParentTag(i, r, a), this.options.cdataPropName) { var y; r.add(this.options.cdataPropName, [(y = {}, y[this.options.textNodeName] = T, y)]); } else { let O = this.parseTextData(T, r.tagname, a, !0, !1, !0); O == null && (O = ''), r.add(this.options.textNodeName, O); }o = E + 2; } else { const A = m(t, o, this.options.removeNSPrefix); let w = A.tagName; const P = A.rawTagName; let C = A.tagExp; const I = A.attrExpPresent; const F = A.closeIndex; this.options.transformTagName && (w = this.options.transformTagName(w)), r && i && r.tagname !== '!xml' && (i = this.saveTextToParentTag(i, r, a, !1)); const D = r; if (D && this.options.unpairedTags.indexOf(D.tagname) !== -1 && (r = this.tagsNodeStack.pop(), a = a.substring(0, a.lastIndexOf('.'))), w !== e.tagname && (a += a ? `.${w}` : w), this.isItStopNode(this.options.stopNodes, a, w)) { let S = ''; if (C.length > 0 && C.lastIndexOf('/') === C.length - 1)o = A.closeIndex; else if (this.options.unpairedTags.indexOf(w) !== -1)o = A.closeIndex; else { const j = this.readStopNodeData(t, P, F + 1); if (!j) throw new Error(`Unexpected end of ${P}`); o = j.i, S = j.tagContent; } const k = new n(w); w !== C && I && (k[':@'] = this.buildAttributesMap(C, a, w)), S && (S = this.parseTextData(S, w, a, !0, I, !0, !0)), a = a.substr(0, a.lastIndexOf('.')), k.add(this.options.textNodeName, S), this.addChild(r, k, a); } else { if (C.length > 0 && C.lastIndexOf('/') === C.length - 1) { w[w.length - 1] === '/' ? (w = w.substr(0, w.length - 1), a = a.substr(0, a.length - 1), C = w) : C = C.substr(0, C.length - 1), this.options.transformTagName && (w = this.options.transformTagName(w)); const V = new n(w); w !== C && I && (V[':@'] = this.buildAttributesMap(C, a, w)), this.addChild(r, V, a), a = a.substr(0, a.lastIndexOf('.')); } else { const _ = new n(w); this.tagsNodeStack.push(r), w !== C && I && (_[':@'] = this.buildAttributesMap(C, a, w)), this.addChild(r, _, a), r = _; }i = '', o = F; } } else i += t[o]; return e.child; }; function f(t, e, r) { const i = this.options.updateTag(e.tagname, r, e[':@']); !1 === i || (typeof i === 'string' ? (e.tagname = i, t.addChild(e)) : t.addChild(e)); } const g = function (t) { if (this.options.processEntities) { for (const e in this.docTypeEntities) { const r = this.docTypeEntities[e]; t = t.replace(r.regx, r.val); } for (const i in this.lastEntities) { const n = this.lastEntities[i]; t = t.replace(n.regex, n.val); } if (this.options.htmlEntities) for (const s in this.htmlEntities) { const a = this.htmlEntities[s]; t = t.replace(a.regex, a.val); }t = t.replace(this.ampEntity.regex, this.ampEntity.val); } return t; }; function c(t, e, r, i) { return t && (void 0 === i && (i = Object.keys(e.child).length === 0), void 0 !== (t = this.parseTextData(t, e.tagname, r, !1, !!e[':@'] && Object.keys(e[':@']).length !== 0, i)) && t !== '' && e.add(this.options.textNodeName, t), t = ''), t; } function v(t, e, r) { const i = `*.${r}`; for (const n in t) { const s = t[n]; if (i === s || e === s) return !0; } return !1; } function x(t, e, r, i) { const n = t.indexOf(e, r); if (n === -1) throw new Error(i); return n + e.length - 1; } function m(t, e, r, i) {
        void 0 === i && (i = '>'); const n = (function (t, e, r) { let i; void 0 === r && (r = '>'); for (let n = '', s = e; s < t.length; s++) { let a = t[s]; if (i)a === i && (i = ''); else if (a === '"' || a === "'")i = a; else if (a === r[0]) { if (!r[1]) return { data: n, index: s }; if (t[s + 1] === r[1]) return { data: n, index: s }; } else a === '\t' && (a = ' '); n += a; } }(t, e + 1, i)); if (n) {
          let s = n.data; const a = n.index; const o = s.search(/\s/); let u = s; let l = !0; o !== -1 && (u = s.substr(0, o).replace(/\s\s*$/, ''), s = s.substr(o + 1)); const h = u; if (r) { const p = u.indexOf(':'); p !== -1 && (l = (u = u.substr(p + 1)) !== n.data.substr(p + 1)); } return {
            tagName: u, tagExp: s, closeIndex: a, attrExpPresent: l, rawTagName: h,
          };
        }
      } function N(t, e, r) { for (let i = r, n = 1; r < t.length; r++) if (t[r] === '<') if (t[r + 1] === '/') { const s = x(t, '>', r, `${e} is not closed`); if (t.substring(r + 2, s).trim() === e && --n == 0) return { tagContent: t.substring(i, r), i: s }; r = s; } else if (t[r + 1] === '?')r = x(t, '?>', r + 1, 'StopNode is not closed.'); else if (t.substr(r + 1, 3) === '!--')r = x(t, '--\x3e', r + 3, 'StopNode is not closed.'); else if (t.substr(r + 1, 2) === '![')r = x(t, ']]>', r, 'StopNode is not closed.') - 2; else { const a = m(t, r, '>'); a && ((a && a.tagName) === e && a.tagExp[a.tagExp.length - 1] !== '/' && n++, r = a.closeIndex); } } function b(t, e, r) { if (e && typeof t === 'string') { const n = t.trim(); return n === 'true' || n !== 'false' && a(t, r); } return i.isExist(t) ? t : ''; }t.exports = function (t) {
        this.options = t, this.currentNode = null, this.tagsNodeStack = [], this.docTypeEntities = {}, this.lastEntities = {
          apos: { regex: /&(apos|#39|#x27);/g, val: "'" }, gt: { regex: /&(gt|#62|#x3E);/g, val: '>' }, lt: { regex: /&(lt|#60|#x3C);/g, val: '<' }, quot: { regex: /&(quot|#34|#x22);/g, val: '"' },
        }, this.ampEntity = { regex: /&(amp|#38|#x26);/g, val: '&' }, this.htmlEntities = {
          space: { regex: /&(nbsp|#160);/g, val: ' ' }, cent: { regex: /&(cent|#162);/g, val: '¢' }, pound: { regex: /&(pound|#163);/g, val: '£' }, yen: { regex: /&(yen|#165);/g, val: '¥' }, euro: { regex: /&(euro|#8364);/g, val: '€' }, copyright: { regex: /&(copy|#169);/g, val: '©' }, reg: { regex: /&(reg|#174);/g, val: '®' }, inr: { regex: /&(inr|#8377);/g, val: '₹' },
        }, this.addExternalEntities = o, this.parseXml = d, this.parseTextData = u, this.resolveNameSpace = l, this.buildAttributesMap = p, this.isItStopNode = v, this.replaceEntitiesValue = g, this.readStopNodeData = N, this.saveTextToParentTag = c, this.addChild = f;
      };
    },
    870: (t, e, r) => { const i = r(348).buildOptions; const n = r(498); const s = r(400).prettify; const a = r(239); const o = (function () { function t(t) { this.externalEntities = {}, this.options = i(t); } const e = t.prototype; return e.parse = function (t, e) { if (typeof t === 'string');else { if (!t.toString) throw new Error('XML data is accepted in String or Bytes[] form.'); t = t.toString(); } if (e) { !0 === e && (e = {}); const r = a.validate(t, e); if (!0 !== r) throw Error(`${r.err.msg}:${r.err.line}:${r.err.col}`); } const i = new n(this.options); i.addExternalEntities(this.externalEntities); const o = i.parseXml(t); return this.options.preserveOrder || void 0 === o ? o : s(o, this.options); }, e.addEntity = function (t, e) { if (e.indexOf('&') !== -1) throw new Error("Entity value can't have '&'"); if (t.indexOf('&') !== -1 || t.indexOf(';') !== -1) throw new Error("An entity must be set without '&' and ';'. Eg. use '#xD' for '&#xD;'"); if (e === '&') throw new Error("An entity with value '&' is not permitted"); this.externalEntities[t] = e; }, t; }()); t.exports = o; },
    400: (t, e) => {
      function r(t, e, a) { for (var o, u = {}, l = 0; l < t.length; l++) { var h; const p = t[l]; const d = i(p); if (h = void 0 === a ? d : `${a}.${d}`, d === e.textNodeName) void 0 === o ? o = p[d] : o += `${p[d]}`; else { if (void 0 === d) continue; if (p[d]) { let f = r(p[d], e, h); const g = s(f, e); p[':@'] ? n(f, p[':@'], h, e) : Object.keys(f).length !== 1 || void 0 === f[e.textNodeName] || e.alwaysCreateTextNode ? Object.keys(f).length === 0 && (e.alwaysCreateTextNode ? f[e.textNodeName] = '' : f = '') : f = f[e.textNodeName], void 0 !== u[d] && u.hasOwnProperty(d) ? (Array.isArray(u[d]) || (u[d] = [u[d]]), u[d].push(f)) : e.isArray(d, h, g) ? u[d] = [f] : u[d] = f; } } } return typeof o === 'string' ? o.length > 0 && (u[e.textNodeName] = o) : void 0 !== o && (u[e.textNodeName] = o), u; } function i(t) { for (let e = Object.keys(t), r = 0; r < e.length; r++) { const i = e[r]; if (i !== ':@') return i; } } function n(t, e, r, i) { if (e) for (let n = Object.keys(e), s = n.length, a = 0; a < s; a++) { const o = n[a]; i.isArray(o, `${r}.${o}`, !0, !0) ? t[o] = [e[o]] : t[o] = e[o]; } } function s(t, e) { const r = e.textNodeName; const i = Object.keys(t).length; return i === 0 || !(i !== 1 || !t[r] && typeof t[r] !== 'boolean' && t[r] !== 0); }e.prettify = function (t, e) { return r(t, e); };
    },
    876: (t) => {
      const e = (function () { function t(t) { this.tagname = t, this.child = [], this[':@'] = {}; } const e = t.prototype; return e.add = function (t, e) { let r; t === '__proto__' && (t = '#__proto__'), this.child.push(((r = {})[t] = e, r)); }, e.addChild = function (t) { let e; let r; t.tagname === '__proto__' && (t.tagname = '#__proto__'), t[':@'] && Object.keys(t[':@']).length > 0 ? this.child.push(((e = {})[t.tagname] = t.child, e[':@'] = t[':@'], e)) : this.child.push(((r = {})[t.tagname] = t.child, r)); }, t; }()); t.exports = e;
    },
  }; const e = {}; const r = (function r(i) { const n = e[i]; if (void 0 !== n) return n.exports; const s = e[i] = { exports: {} }; return t[i](s, s.exports, r), s.exports; }(316)); fxp = r;
})();
// # sourceMappingURL=fxp.min.js.map
